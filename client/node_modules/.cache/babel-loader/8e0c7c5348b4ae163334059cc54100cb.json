{"ast":null,"code":"const fs = require('fs');\n\nconst crypto = require('crypto');\n\nconst zlib = require('zlib');\n\nmodule.exports = new class LibHash {\n  // opens the file, gzip the content and base64 encode it\n  computeSubContent(path) {\n    return new Promise((resolve, reject) => {\n      fs.readFile(path, (err, data) => {\n        if (err) return reject(err);\n        zlib.deflate(data, (err, buffer) => {\n          if (err) return reject(err);\n          resolve(buffer.toString('base64'));\n        });\n      });\n    });\n  } // get md5 of a file\n\n\n  computeMD5(path) {\n    return new Promise((resolve, reject) => {\n      let hash = crypto.createHash('md5');\n      fs.createReadStream(path).on('data', data => hash.update(data, 'utf8')).on('end', () => resolve(hash.digest('hex'))) // md5 checksum\n      .on('error', reject);\n    });\n  }\n\n  computeHash(path) {\n    // based on node-opensubtitles-api, under MIT - Copyright (c) 2015 ka2er\n    return new Promise((resolve, reject) => {\n      // get file size, first 64kb, last 64kb and summup everything\n      let chunk_size = 65536; //64 * 1024\n\n      let buf_start = Buffer.alloc(chunk_size * 2);\n      let buf_end = Buffer.alloc(chunk_size * 2);\n      let file_size = 0;\n      let checksum;\n      let array_checksum = Array();\n\n      const checksumReady = checksum_part => {\n        array_checksum.push(checksum_part);\n\n        if (array_checksum.length === 3) {\n          checksum = this.sumHex64bits(array_checksum[0], array_checksum[1]);\n          checksum = this.sumHex64bits(checksum, array_checksum[2]);\n          checksum = checksum.substr(-16);\n          resolve({\n            moviehash: this.padLeft(checksum, '0', 16),\n            moviebytesize: file_size.toString()\n          });\n        }\n      };\n\n      fs.stat(path, (err, stat) => {\n        if (err) return reject(err);\n        file_size = stat.size;\n        checksumReady(file_size.toString(16));\n        fs.open(path, 'r', (err, fd) => {\n          if (err) return reject(err);\n          fs.read(fd, buf_start, 0, chunk_size * 2, 0, (er1, bytesRead, buf1) => {\n            fs.read(fd, buf_end, 0, chunk_size * 2, file_size - chunk_size, (er2, bytesRead, buf2) => {\n              fs.close(fd, er3 => {\n                if (er1 || er2) return reject(er1 || er2); //er3 is not breaking\n\n                checksumReady(this.checksumBuffer(buf1, 16));\n                checksumReady(this.checksumBuffer(buf2, 16));\n              });\n            });\n          });\n        });\n      });\n    });\n  } // read 64 bits from buffer starting at offset as LITTLE ENDIAN hex\n\n\n  read64LE(buffer, offset) {\n    const ret_64_be = buffer.toString('hex', offset * 8, (offset + 1) * 8);\n    const array = Array();\n\n    for (let i = 0; i < 8; i++) {\n      array.push(ret_64_be.substr(i * 2, 2));\n    }\n\n    array.reverse();\n    return array.join('');\n  } // compute checksum of the buffer splitting by chunk of lengths bits\n\n\n  checksumBuffer(buf, length) {\n    let checksum = 0;\n    let checksum_hex = 0;\n\n    for (let i = 0; i < buf.length / length; i++) {\n      checksum_hex = this.read64LE(buf, i);\n      checksum = this.sumHex64bits(checksum.toString(), checksum_hex).substr(-16);\n    }\n\n    return checksum;\n  } // calculate hex sum between 2 64bits hex numbers\n\n\n  sumHex64bits(n1, n2) {\n    if (n1.length < 16) n1 = this.padLeft(n1, '0', 16);\n    if (n2.length < 16) n2 = this.padLeft(n2, '0', 16); // 1st 32 bits\n\n    let n1_0 = n1.substr(0, 8);\n    let n2_0 = n2.substr(0, 8);\n    let i_0 = parseInt(n1_0, 16) + parseInt(n2_0, 16); // 2nd 32 bits\n\n    let n1_1 = n1.substr(8, 8);\n    let n2_1 = n2.substr(8, 8);\n    let i_1 = parseInt(n1_1, 16) + parseInt(n2_1, 16); // back to hex\n\n    let h_1 = i_1.toString(16);\n    let i_1_over = 0;\n\n    if (h_1.length > 8) {\n      i_1_over = parseInt(h_1.substr(0, h_1.length - 8), 16);\n    } else {\n      h_1 = this.padLeft(h_1, '0', 8);\n    }\n\n    let h_0 = (i_1_over + i_0).toString(16);\n    return h_0 + h_1.substr(-8);\n  } // pad left with c up to length characters\n\n\n  padLeft(str, c, length) {\n    while (str.length < length) {\n      str = c.toString() + str;\n    }\n\n    return str;\n  }\n\n}();","map":{"version":3,"sources":["/home/pinchas/code/projects/movie-finder/node_modules/opensubtitles-api/lib/hash.js"],"names":["fs","require","crypto","zlib","module","exports","LibHash","computeSubContent","path","Promise","resolve","reject","readFile","err","data","deflate","buffer","toString","computeMD5","hash","createHash","createReadStream","on","update","digest","computeHash","chunk_size","buf_start","Buffer","alloc","buf_end","file_size","checksum","array_checksum","Array","checksumReady","checksum_part","push","length","sumHex64bits","substr","moviehash","padLeft","moviebytesize","stat","size","open","fd","read","er1","bytesRead","buf1","er2","buf2","close","er3","checksumBuffer","read64LE","offset","ret_64_be","array","i","reverse","join","buf","checksum_hex","n1","n2","n1_0","n2_0","i_0","parseInt","n1_1","n2_1","i_1","h_1","i_1_over","h_0","str","c"],"mappings":"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","sourcesContent":["const fs = require('fs')\r\nconst crypto = require('crypto')\r\nconst zlib = require('zlib')\r\n\r\nmodule.exports = new class LibHash {\r\n\r\n    // opens the file, gzip the content and base64 encode it\r\n    computeSubContent(path) {\r\n        return new Promise((resolve, reject) => {\r\n            fs.readFile(path, (err, data) => {\r\n                if (err) return reject(err)\r\n                zlib.deflate(data, (err, buffer) => {\r\n                    if (err) return reject(err)\r\n                    resolve(buffer.toString('base64'))\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    // get md5 of a file\r\n    computeMD5(path) {\r\n        return new Promise((resolve, reject) => {\r\n            let hash = crypto.createHash('md5')\r\n\r\n            fs.createReadStream(path)\r\n                .on('data', data => hash.update(data, 'utf8'))\r\n                .on('end', () => resolve(hash.digest('hex'))) // md5 checksum\r\n                .on('error', reject)\r\n        })\r\n    }\r\n\r\n    computeHash(path) {\r\n        // based on node-opensubtitles-api, under MIT - Copyright (c) 2015 ka2er\r\n\r\n        return new Promise((resolve, reject) => {\r\n            // get file size, first 64kb, last 64kb and summup everything\r\n            let chunk_size = 65536 //64 * 1024\r\n            let buf_start = Buffer.alloc(chunk_size * 2)\r\n            let buf_end = Buffer.alloc(chunk_size * 2)\r\n            let file_size = 0\r\n            let checksum\r\n            let array_checksum = Array()\r\n\r\n            const checksumReady = checksum_part => {\r\n                array_checksum.push(checksum_part)\r\n                if (array_checksum.length === 3) {\r\n                    checksum = this.sumHex64bits(array_checksum[0], array_checksum[1])\r\n                    checksum = this.sumHex64bits(checksum, array_checksum[2])\r\n                    checksum = checksum.substr(-16)\r\n\r\n                    resolve({\r\n                        moviehash: this.padLeft(checksum, '0', 16),\r\n                        moviebytesize: file_size.toString()\r\n                    })\r\n                }\r\n            }\r\n\r\n            fs.stat(path, (err, stat) => {\r\n                if (err) return reject(err)\r\n\r\n                file_size = stat.size\r\n\r\n                checksumReady(file_size.toString(16))\r\n\r\n                fs.open(path, 'r', (err, fd) => {\r\n                    if (err) return reject(err)\r\n\r\n                    fs.read(fd, buf_start, 0, chunk_size * 2, 0, (er1, bytesRead, buf1) => {\r\n                        fs.read(fd, buf_end, 0, chunk_size * 2, file_size - chunk_size, (er2, bytesRead, buf2) => {\r\n                            fs.close(fd, er3 => {\r\n                                if (er1 || er2) return reject(er1 || er2) //er3 is not breaking\r\n                                checksumReady(this.checksumBuffer(buf1, 16))\r\n                                checksumReady(this.checksumBuffer(buf2, 16))\r\n                            })\r\n                        })\r\n                    })\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    // read 64 bits from buffer starting at offset as LITTLE ENDIAN hex\r\n    read64LE(buffer, offset) {\r\n        const ret_64_be = buffer.toString('hex', offset * 8, ((offset + 1) * 8))\r\n        const array = Array()\r\n        for (let i = 0; i < 8; i++) {\r\n            array.push(ret_64_be.substr(i * 2, 2))\r\n        }\r\n        array.reverse()\r\n        return array.join('')\r\n    }\r\n\r\n    // compute checksum of the buffer splitting by chunk of lengths bits\r\n    checksumBuffer(buf, length) {\r\n        let checksum = 0\r\n        let checksum_hex = 0\r\n        for (let i = 0; i < (buf.length / length); i++) {\r\n            checksum_hex = this.read64LE(buf, i)\r\n            checksum = this.sumHex64bits(checksum.toString(), checksum_hex).substr(-16)\r\n        }\r\n        return checksum\r\n    }\r\n\r\n    // calculate hex sum between 2 64bits hex numbers\r\n    sumHex64bits(n1, n2) {\r\n        if (n1.length < 16) n1 = this.padLeft(n1, '0', 16)\r\n        if (n2.length < 16) n2 = this.padLeft(n2, '0', 16)\r\n\r\n        // 1st 32 bits\r\n        let n1_0 = n1.substr(0, 8)\r\n        let n2_0 = n2.substr(0, 8)\r\n        let i_0 = parseInt(n1_0, 16) + parseInt(n2_0, 16)\r\n\r\n        // 2nd 32 bits\r\n        let n1_1 = n1.substr(8, 8)\r\n        let n2_1 = n2.substr(8, 8)\r\n        let i_1 = parseInt(n1_1, 16) + parseInt(n2_1, 16)\r\n\r\n        // back to hex\r\n        let h_1 = i_1.toString(16)\r\n        let i_1_over = 0\r\n        if (h_1.length > 8) {\r\n            i_1_over = parseInt(h_1.substr(0, h_1.length - 8), 16)\r\n        } else {\r\n            h_1 = this.padLeft(h_1, '0', 8)\r\n        }\r\n\r\n        let h_0 = (i_1_over + i_0).toString(16)\r\n\r\n        return h_0 + h_1.substr(-8)\r\n    }\r\n\r\n    // pad left with c up to length characters\r\n    padLeft(str, c, length) {\r\n        while (str.length < length) {\r\n            str = c.toString() + str\r\n        }\r\n        return str\r\n    }\r\n}"]},"metadata":{},"sourceType":"script"}