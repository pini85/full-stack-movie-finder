{"ast":null,"code":"const OS = require('./opensubtitles.js');\n\nconst libhash = require('./hash.js');\n\nconst path = require('path');\n\nmodule.exports = new class LibSearch {\n  checkHash(input) {\n    return new Promise((resolve, reject) => {\n      if (!input.hash && !input.path) return resolve(false);\n      if (!input.hash && input.path) return libhash.computeHash(input.path).then(resolve).catch(reject);\n      const tmpObj = {\n        moviehash: input.hash\n      };\n      if (input.filesize) tmpObj.moviebytesize = input.filesize.toString();\n      resolve(tmpObj);\n    });\n  }\n\n  optimizeQueryTerms(input) {\n    // parse\n    const normalize = this.normalizeProt();\n    input.imdbid = input.imdbid && parseInt(input.imdbid.toString().replace('tt', ''), 10);\n    input.season = input.season && parseInt(input.season);\n    input.episode = input.episode && parseInt(input.episode);\n    input.hash = input.hash && input.hash.toString().length >= 32 && input.hash.toString().toLowerCase();\n    input.filesize = input.filesize && parseInt(input.filesize);\n    input.fps = input.fps && input.fps.toString();\n    input.filename = input.filename || input.path && path.basename(input.path);\n    return this.checkHash(input).then(obj => {\n      const output = Array();\n      let i = 0;\n\n      if (obj) {\n        input.hash = obj.moviehash.toLowerCase();\n        input.filesize = parseInt(obj.moviebytesize);\n      } // first data call\n\n\n      if (input.hash || input.filesize) {\n        output[i] = {\n          moviehash: input.hash && input.hash,\n          moviebytesize: input.filesize && input.filesize.toString()\n        };\n        i++;\n      }\n\n      if (input.filename) {\n        // second data call\n        output[i] = Object();\n        output[i].tag = input.filename;\n        i++;\n      }\n\n      if (input.imdbid) {\n        // third data call\n        output[i] = Object();\n        output[i].imdbid = input.imdbid.toString();\n\n        if (input.season && input.episode) {\n          output[i].season = input.season.toString();\n          output[i].episode = input.episode.toString();\n        }\n\n        i++;\n      }\n\n      if (!input.imdbid && !input.hash && !input.path && !input.filename && input.query) {\n        // fallback\n        output[i] = Object();\n        output[i].query = input.query;\n\n        if (input.season && input.episode) {\n          output[i].season = input.season.toString();\n          output[i].episode = input.episode.toString();\n        }\n\n        i++;\n      } // mandatory lang parameter\n\n\n      for (let o of output) {\n        o.sublanguageid = input.sublanguageid || 'all';\n      }\n\n      return output;\n    });\n  }\n\n  normalizeProt() {\n    const from = 'ÃÀÁÄÂÈÉËÊÌÍÏÎÒÓÖÔÙÚÜÛãàáäâèéëêìíïîòóöôùúüûÑñÇç';\n    const to = 'AAAAAEEEEIIIIOOOOUUUUaaaaaeeeeiiiioooouuuunncc';\n    const mapping = Object();\n\n    for (let i = 0, j = from.length; i < j; i++) {\n      mapping[from.charAt(i)] = to.charAt(i);\n    }\n\n    return str => {\n      const ret = Array();\n\n      for (let i = 0, j = str.length; i < j; i++) {\n        let c = str.charAt(i);\n        ret.push(mapping[c] || c);\n      }\n\n      return ret.join('');\n    };\n  }\n\n  optimizeSubs(response, input) {\n    // based on OpenSRTJS, under MIT - Copyright (c) 2014 Eóin Martin\n    let inputTags;\n    let inputTagsDic = Object();\n    const normalize = this.normalizeProt();\n\n    const matchTags = (sub, maxScore) => {\n      if (!input.filename) return 0;\n      if (!inputTags) inputTags = input.filename && normalize(input.filename).toLowerCase().match(/[a-z0-9]{2,}/gi);\n      if (!inputTags || inputTags.length <= 2) return 0;\n      const subNames = normalize(sub.MovieReleaseName + '_' + sub.SubFileName);\n      const subTags = subNames.toLowerCase().match(/[a-z0-9]{2,}/gi);\n      if (!subTags.length) return 0;\n\n      for (let tag of inputTags) inputTagsDic[tag] = false;\n\n      let matches = 0;\n\n      for (let subTag of subTags) {\n        // is term in filename, only once\n        if (inputTagsDic[subTag] == false) {\n          inputTagsDic[subTag] = true;\n          matches++;\n        }\n      }\n\n      return parseInt(matches / inputTags.length * maxScore);\n    };\n\n    const subtitles = Object(); // if string passed as supported extension, convert to array\n\n    if (input.extensions && typeof input.extensions === 'string') input.extensions = [input.extensions]; // if no supported extensions passed, default to 'srt'\n\n    if (!input.extensions || !input.extensions instanceof Array) input.extensions = ['srt']; // remove duplicate and empty\n\n    var seen = {};\n    response = response.filter(sub => {\n      return sub && seen.hasOwnProperty(sub.IDSubtitle) ? false : seen[sub.IDSubtitle] = true;\n    });\n    return Promise.all(response.map(sub => {\n      // parse\n      sub.imdbid = sub.SeriesIMDBParent && sub.SeriesIMDBParent !== '0' ? parseInt(sub.SeriesIMDBParent, 10) : sub.IDMovieImdb && parseInt(sub.IDMovieImdb, 10);\n      sub.season = sub.SeriesSeason && parseInt(sub.SeriesSeason);\n      sub.episode = sub.SeriesEpisode && parseInt(sub.SeriesEpisode);\n      sub.filesize = parseInt(sub.MovieByteSize);\n      sub.hash = sub.MovieHash != \"0\" && sub.MovieHash.toLowerCase();\n      sub.fps = sub.MovieFPS && parseInt(sub.MovieFPS) > 0 && sub.MovieFPS.toString(); // check: extension, imdb, episode\n\n      if (input.extensions.indexOf(sub.SubFormat) == -1 || input.imdbid && input.imdbid != sub.imdbid || input.season && input.episode && (input.season != sub.season || input.episode != sub.episode)) return;\n      const tmp = {\n        url: input.gzip ? sub.SubDownloadLink : sub.SubDownloadLink.replace('.gz', ''),\n        langcode: sub.ISO639,\n        downloads: parseInt(sub.SubDownloadsCnt),\n        lang: sub.LanguageName,\n        encoding: sub.SubEncoding,\n        id: sub.IDSubtitleFile,\n        filename: sub.SubFileName,\n        date: sub.SubAddDate,\n        score: 0,\n        fps: parseFloat(sub.MovieFPS) || null,\n        format: sub.SubFormat,\n        utf8: input.gzip ? sub.SubDownloadLink.replace('download/', 'download/subencoding-utf8/') : sub.SubDownloadLink.replace('.gz', '').replace('download/', 'download/subencoding-utf8/'),\n        vtt: sub.SubDownloadLink.replace('download/', 'download/subformat-vtt/').replace('.gz', '')\n      }; // version            \n\n      if (input.hash && sub.hash == input.hash || input.filesize && input.filesize == sub.filesize) {\n        tmp.score += 9;\n      } else {\n        tmp.score += matchTags(sub, 7);\n        if (input.fps && sub.fps && (sub.fps.startsWith(input.fps) || input.fps.startsWith(sub.fps))) tmp.score += 1;\n      } // rank \n\n\n      sub.UserRank.match(/trusted|administrator/) && (tmp.score += 0.5);\n      sub.UserRank.match(/platinum member|gold member/) && (tmp.score += 0.2); // store subs for sorting\n\n      if (!subtitles[tmp.langcode]) {\n        subtitles[tmp.langcode] = [tmp];\n      } else {\n        subtitles[tmp.langcode][Object.keys(subtitles[tmp.langcode]).length] = tmp;\n      }\n\n      return;\n    })).then(() => subtitles);\n  }\n\n  filter(list = Object(), input) {\n    const subtitles = Object();\n\n    if (!input.limit || isNaN(input.limit) && ['best', 'all'].indexOf(input.limit.toLowerCase()) == -1) {\n      input.limit = 'best';\n    }\n\n    for (let i in list) {\n      let lang = list[i];\n      let langcode = lang[0].langcode; // sort by score, sub-sort by downloads\n\n      lang = lang.sort((a, b) => {\n        if (a.score === b.score) {\n          let x = a.downloads;\n          let y = b.downloads;\n          return y < x ? -1 : y > x ? 1 : 0;\n        }\n\n        return b.score - a.score;\n      }); // filter\n\n      switch (input.limit.toString().toLowerCase()) {\n        case 'best':\n          // keep only the first (best) item\n          subtitles[langcode] = lang[0];\n          break;\n\n        case 'all':\n          // all good already\n          subtitles[langcode] = lang;\n          break;\n\n        default:\n          // keep only n = input.limit items\n          subtitles[langcode] = lang.slice(0, parseInt(input.limit));\n      }\n    }\n\n    return Promise.resolve(subtitles);\n  }\n\n}();","map":{"version":3,"sources":["/home/pinchas/code/projects/movie-finder/node_modules/opensubtitles-api/lib/search.js"],"names":["OS","require","libhash","path","module","exports","LibSearch","checkHash","input","Promise","resolve","reject","hash","computeHash","then","catch","tmpObj","moviehash","filesize","moviebytesize","toString","optimizeQueryTerms","normalize","normalizeProt","imdbid","parseInt","replace","season","episode","length","toLowerCase","fps","filename","basename","obj","output","Array","i","Object","tag","query","o","sublanguageid","from","to","mapping","j","charAt","str","ret","c","push","join","optimizeSubs","response","inputTags","inputTagsDic","matchTags","sub","maxScore","match","subNames","MovieReleaseName","SubFileName","subTags","matches","subTag","subtitles","extensions","seen","filter","hasOwnProperty","IDSubtitle","all","map","SeriesIMDBParent","IDMovieImdb","SeriesSeason","SeriesEpisode","MovieByteSize","MovieHash","MovieFPS","indexOf","SubFormat","tmp","url","gzip","SubDownloadLink","langcode","ISO639","downloads","SubDownloadsCnt","lang","LanguageName","encoding","SubEncoding","id","IDSubtitleFile","date","SubAddDate","score","parseFloat","format","utf8","vtt","startsWith","UserRank","keys","list","limit","isNaN","sort","a","b","x","y","slice"],"mappings":"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","sourcesContent":["const OS = require('./opensubtitles.js')\r\nconst libhash = require('./hash.js')\r\nconst path = require('path')\r\n\r\nmodule.exports = new class LibSearch {\r\n\r\n    checkHash(input) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!input.hash && !input.path) return resolve(false)\r\n\r\n            if (!input.hash && input.path) return libhash.computeHash(input.path).then(resolve).catch(reject)\r\n\r\n            const tmpObj = { moviehash: input.hash }\r\n            if (input.filesize) tmpObj.moviebytesize = input.filesize.toString()\r\n            resolve(tmpObj)\r\n        })\r\n    }\r\n\r\n    optimizeQueryTerms(input) {\r\n        // parse\r\n        const normalize = this.normalizeProt();\r\n        input.imdbid = input.imdbid && parseInt(input.imdbid.toString().replace('tt', ''), 10)\r\n        input.season = input.season && parseInt(input.season)\r\n        input.episode = input.episode && parseInt(input.episode)\r\n        input.hash = input.hash && input.hash.toString().length >= 32 && input.hash.toString().toLowerCase()\r\n        input.filesize = input.filesize && parseInt(input.filesize)\r\n        input.fps = input.fps && input.fps.toString()\r\n        input.filename = input.filename || input.path && path.basename(input.path)\r\n\r\n\r\n        return this.checkHash(input).then(obj => {\r\n            const output = Array()\r\n            let i = 0\r\n\r\n            if (obj) {\r\n                input.hash = obj.moviehash.toLowerCase()\r\n                input.filesize = parseInt(obj.moviebytesize)\r\n            }\r\n            // first data call\r\n            if (input.hash || input.filesize) {\r\n                output[i] = {\r\n                    moviehash: input.hash && input.hash,\r\n                    moviebytesize: input.filesize && input.filesize.toString()\r\n                }\r\n                i++\r\n            }\r\n\r\n            if (input.filename) { // second data call\r\n                output[i] = Object()\r\n                output[i].tag = input.filename\r\n                i++\r\n            }\r\n\r\n            if (input.imdbid) { // third data call\r\n                output[i] = Object()\r\n                output[i].imdbid = input.imdbid.toString()\r\n\r\n                if (input.season && input.episode) {\r\n                    output[i].season = input.season.toString()\r\n                    output[i].episode = input.episode.toString()\r\n                }\r\n                i++\r\n            }\r\n\r\n            if (!input.imdbid && !input.hash && !input.path && !input.filename && input.query) { // fallback\r\n                output[i] = Object()\r\n                output[i].query = input.query\r\n\r\n                if (input.season && input.episode) {\r\n                    output[i].season = input.season.toString()\r\n                    output[i].episode = input.episode.toString()\r\n                }\r\n                i++\r\n            }\r\n\r\n            // mandatory lang parameter\r\n            for (let o of output) {\r\n                o.sublanguageid = input.sublanguageid || 'all'\r\n            }\r\n\r\n            return output\r\n        })\r\n    }\r\n\r\n    normalizeProt() {\r\n        const from = 'ÃÀÁÄÂÈÉËÊÌÍÏÎÒÓÖÔÙÚÜÛãàáäâèéëêìíïîòóöôùúüûÑñÇç'\r\n        const to = 'AAAAAEEEEIIIIOOOOUUUUaaaaaeeeeiiiioooouuuunncc'\r\n        const mapping = Object()\r\n\r\n        for (let i = 0, j = from.length; i < j; i++) {\r\n            mapping[from.charAt(i)] = to.charAt(i)\r\n        }\r\n\r\n        return str => {\r\n            const ret = Array()\r\n            for (let i = 0, j = str.length; i < j; i++) {\r\n                let c = str.charAt(i)\r\n                ret.push(mapping[c] || c)\r\n            }\r\n            return ret.join('')\r\n        }\r\n    }\r\n    optimizeSubs(response, input) {\r\n        // based on OpenSRTJS, under MIT - Copyright (c) 2014 Eóin Martin\r\n        let inputTags\r\n        let inputTagsDic = Object()\r\n        const normalize = this.normalizeProt()\r\n        const matchTags = (sub, maxScore) => {\r\n            if (!input.filename) return 0\r\n\r\n            if (!inputTags)\r\n                inputTags = input.filename && normalize(input.filename).toLowerCase().match(/[a-z0-9]{2,}/gi)\r\n\r\n            if (!inputTags || inputTags.length <= 2) return 0\r\n\r\n            const subNames = normalize(sub.MovieReleaseName + '_' + sub.SubFileName)\r\n            const subTags = subNames.toLowerCase().match(/[a-z0-9]{2,}/gi)\r\n\r\n            if (!subTags.length) return 0\r\n\r\n            for (let tag of inputTags) inputTagsDic[tag] = false\r\n\r\n            let matches = 0\r\n            for (let subTag of subTags) { // is term in filename, only once\r\n                if (inputTagsDic[subTag] == false) {\r\n                    inputTagsDic[subTag] = true\r\n                    matches++\r\n                }\r\n            }\r\n\r\n            return parseInt((matches / inputTags.length) * maxScore)\r\n        }\r\n        const subtitles = Object()\r\n\r\n        // if string passed as supported extension, convert to array\r\n        if (input.extensions && typeof input.extensions === 'string') input.extensions = [input.extensions]\r\n\r\n        // if no supported extensions passed, default to 'srt'\r\n        if (!input.extensions || !input.extensions instanceof Array) input.extensions = ['srt']\r\n\r\n        // remove duplicate and empty\r\n        var seen = {}\r\n        response = response.filter(sub => {\r\n            return sub && seen.hasOwnProperty(sub.IDSubtitle) ? false : (seen[sub.IDSubtitle] = true)\r\n        })\r\n\r\n        return Promise.all(response.map(sub => {\r\n            // parse\r\n            sub.imdbid = (sub.SeriesIMDBParent && sub.SeriesIMDBParent !== '0')\r\n                ? parseInt(sub.SeriesIMDBParent, 10)\r\n                : sub.IDMovieImdb && parseInt(sub.IDMovieImdb, 10)\r\n            sub.season = sub.SeriesSeason && parseInt(sub.SeriesSeason)\r\n            sub.episode = sub.SeriesEpisode && parseInt(sub.SeriesEpisode)\r\n            sub.filesize = parseInt(sub.MovieByteSize)\r\n            sub.hash = sub.MovieHash != \"0\" && sub.MovieHash.toLowerCase()\r\n            sub.fps = sub.MovieFPS && parseInt(sub.MovieFPS) > 0 && sub.MovieFPS.toString()\r\n\r\n            // check: extension, imdb, episode\r\n            if ((input.extensions.indexOf(sub.SubFormat) == -1)\r\n                || (input.imdbid && input.imdbid != sub.imdbid)\r\n                || (input.season && input.episode && (input.season != sub.season || input.episode != sub.episode))) return\r\n\r\n            const tmp = {\r\n                url: input.gzip ? sub.SubDownloadLink : sub.SubDownloadLink.replace('.gz', ''),\r\n                langcode: sub.ISO639,\r\n                downloads: parseInt(sub.SubDownloadsCnt),\r\n                lang: sub.LanguageName,\r\n                encoding: sub.SubEncoding,\r\n                id: sub.IDSubtitleFile,\r\n                filename: sub.SubFileName,\r\n                date: sub.SubAddDate,\r\n                score: 0,\r\n                fps: parseFloat(sub.MovieFPS) || null,\r\n                format: sub.SubFormat,\r\n                utf8: input.gzip ? sub.SubDownloadLink.replace('download/', 'download/subencoding-utf8/') : sub.SubDownloadLink.replace('.gz', '').replace('download/', 'download/subencoding-utf8/'),\r\n                vtt: sub.SubDownloadLink.replace('download/', 'download/subformat-vtt/').replace('.gz', '')\r\n            }\r\n\r\n            // version            \r\n            if (input.hash && sub.hash == input.hash || input.filesize && input.filesize == sub.filesize) {\r\n                tmp.score += 9\r\n            } else {\r\n                tmp.score += matchTags(sub, 7)\r\n                if ((input.fps && sub.fps) && (sub.fps.startsWith(input.fps) || input.fps.startsWith(sub.fps)))\r\n                    (tmp.score += 1)\r\n            }\r\n\r\n            // rank \r\n            sub.UserRank.match(/trusted|administrator/) && (tmp.score += 0.5)\r\n            sub.UserRank.match(/platinum member|gold member/) && (tmp.score += 0.2)\r\n\r\n            // store subs for sorting\r\n            if (!subtitles[tmp.langcode]) {\r\n                subtitles[tmp.langcode] = [tmp]\r\n            } else {\r\n                subtitles[tmp.langcode][Object.keys(subtitles[tmp.langcode]).length] = tmp\r\n            }\r\n\r\n            return\r\n        })).then(() => subtitles)\r\n    }\r\n\r\n    filter(list = Object(), input) {\r\n        const subtitles = Object()\r\n\r\n        if (!input.limit || (isNaN(input.limit) && ['best', 'all'].indexOf(input.limit.toLowerCase()) == -1)) {\r\n            input.limit = 'best'\r\n        }\r\n\r\n        for (let i in list) {\r\n            let lang = list[i]\r\n            let langcode = lang[0].langcode\r\n\r\n            // sort by score, sub-sort by downloads\r\n            lang = lang.sort((a, b) => {\r\n                if (a.score === b.score) {\r\n                    let x = a.downloads\r\n                    let y = b.downloads\r\n                    return y < x ? -1 : y > x ? 1 : 0\r\n                }\r\n                return b.score - a.score\r\n            })\r\n\r\n            // filter\r\n            switch (input.limit.toString().toLowerCase()) {\r\n                case 'best':\r\n                    // keep only the first (best) item\r\n                    subtitles[langcode] = lang[0]\r\n                    break\r\n                case 'all':\r\n                    // all good already\r\n                    subtitles[langcode] = lang\r\n                    break\r\n                default:\r\n                    // keep only n = input.limit items\r\n                    subtitles[langcode] = lang.slice(0, parseInt(input.limit))\r\n            }\r\n        }\r\n\r\n        return Promise.resolve(subtitles)\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}