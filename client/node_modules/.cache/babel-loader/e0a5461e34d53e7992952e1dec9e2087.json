{"ast":null,"code":"var xmlBuilder = require('xmlbuilder'),\n    dateFormatter = require('./date_formatter'),\n    CustomType = require('./customtype');\n/**\n * Creates the XML for an XML-RPC method call.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to pass in the call.\n * @param {Function} callback - function (error, xml) { ... }\n *   - {Object|null} error    - Any errors that occurred while building the XML,\n *                              otherwise null.\n *   - {String} xml           - The method call XML.\n */\n\n\nexports.serializeMethodCall = function (method, params, encoding) {\n  var params = params || [];\n  var options = {\n    version: '1.0',\n    allowSurrogateChars: true\n  };\n\n  if (encoding) {\n    options.encoding = encoding;\n  }\n\n  var xml = xmlBuilder.create('methodCall', options).ele('methodName').txt(method).up().ele('params');\n  params.forEach(function (param) {\n    serializeValue(param, xml.ele('param'));\n  }); // Includes the <?xml ...> declaration\n\n  return xml.doc().toString();\n};\n/**\n * Creates the XML for an XML-RPC method response.\n *\n * @param {mixed} value       - The value to pass in the response.\n * @param {Function} callback - function (error, xml) { ... }\n *   - {Object|null} error    - Any errors that occurred while building the XML,\n *                              otherwise null.\n *   - {String} xml           - The method response XML.\n */\n\n\nexports.serializeMethodResponse = function (result) {\n  var xml = xmlBuilder.create('methodResponse', {\n    version: '1.0',\n    allowSurrogateChars: true\n  }).ele('params').ele('param');\n  serializeValue(result, xml); // Includes the <?xml ...> declaration\n\n  return xml.doc().toString();\n};\n\nexports.serializeFault = function (fault) {\n  var xml = xmlBuilder.create('methodResponse', {\n    version: '1.0',\n    allowSurrogateChars: true\n  }).ele('fault');\n  serializeValue(fault, xml); // Includes the <?xml ...> declaration\n\n  return xml.doc().toString();\n};\n\nfunction serializeValue(value, xml) {\n  var stack = [{\n    value: value,\n    xml: xml\n  }],\n      current = null,\n      valueNode = null,\n      next = null;\n\n  while (stack.length > 0) {\n    current = stack[stack.length - 1];\n\n    if (current.index !== undefined) {\n      // Iterating a compound\n      next = getNextItemsFrame(current);\n\n      if (next) {\n        stack.push(next);\n      } else {\n        stack.pop();\n      }\n    } else {\n      // we're about to add a new value (compound or simple)\n      valueNode = current.xml.ele('value');\n\n      switch (typeof current.value) {\n        case 'boolean':\n          appendBoolean(current.value, valueNode);\n          stack.pop();\n          break;\n\n        case 'string':\n          appendString(current.value, valueNode);\n          stack.pop();\n          break;\n\n        case 'number':\n          appendNumber(current.value, valueNode);\n          stack.pop();\n          break;\n\n        case 'object':\n          if (current.value === null) {\n            valueNode.ele('nil');\n            stack.pop();\n          } else if (current.value instanceof Date) {\n            appendDatetime(current.value, valueNode);\n            stack.pop();\n          } else if (Buffer.isBuffer(current.value)) {\n            appendBuffer(current.value, valueNode);\n            stack.pop();\n          } else if (current.value instanceof CustomType) {\n            current.value.serialize(valueNode);\n            stack.pop();\n          } else {\n            if (Array.isArray(current.value)) {\n              current.xml = valueNode.ele('array').ele('data');\n            } else {\n              current.xml = valueNode.ele('struct');\n              current.keys = Object.keys(current.value);\n            }\n\n            current.index = 0;\n            next = getNextItemsFrame(current);\n\n            if (next) {\n              stack.push(next);\n            } else {\n              stack.pop();\n            }\n          }\n\n          break;\n\n        default:\n          stack.pop();\n          break;\n      }\n    }\n  }\n}\n\nfunction getNextItemsFrame(frame) {\n  var nextFrame = null;\n\n  if (frame.keys) {\n    if (frame.index < frame.keys.length) {\n      var key = frame.keys[frame.index++],\n          member = frame.xml.ele('member').ele('name').text(key).up();\n      nextFrame = {\n        value: frame.value[key],\n        xml: member\n      };\n    }\n  } else if (frame.index < frame.value.length) {\n    nextFrame = {\n      value: frame.value[frame.index],\n      xml: frame.xml\n    };\n    frame.index++;\n  }\n\n  return nextFrame;\n}\n\nfunction appendBoolean(value, xml) {\n  xml.ele('boolean').txt(value ? 1 : 0);\n}\n\nvar illegalChars = /^(?![^<&]*]]>[^<&]*)[^<&]*$/;\n\nfunction appendString(value, xml) {\n  if (value.length === 0) {\n    xml.ele('string');\n  } else if (!illegalChars.test(value)) {\n    xml.ele('string').d(value);\n  } else {\n    xml.ele('string').txt(value);\n  }\n}\n\nfunction appendNumber(value, xml) {\n  if (value % 1 == 0) {\n    xml.ele('int').txt(value);\n  } else {\n    xml.ele('double').txt(value);\n  }\n}\n\nfunction appendDatetime(value, xml) {\n  xml.ele('dateTime.iso8601').txt(dateFormatter.encodeIso8601(value));\n}\n\nfunction appendBuffer(value, xml) {\n  xml.ele('base64').txt(value.toString('base64'));\n}","map":{"version":3,"sources":["/home/pinchas/code/projects/movie-finder/node_modules/xmlrpc/lib/serializer.js"],"names":["xmlBuilder","require","dateFormatter","CustomType","exports","serializeMethodCall","method","params","encoding","options","version","allowSurrogateChars","xml","create","ele","txt","up","forEach","param","serializeValue","doc","toString","serializeMethodResponse","result","serializeFault","fault","value","stack","current","valueNode","next","length","index","undefined","getNextItemsFrame","push","pop","appendBoolean","appendString","appendNumber","Date","appendDatetime","Buffer","isBuffer","appendBuffer","serialize","Array","isArray","keys","Object","frame","nextFrame","key","member","text","illegalChars","test","d","encodeIso8601"],"mappings":"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","sourcesContent":["var xmlBuilder    = require('xmlbuilder')\n  , dateFormatter = require('./date_formatter')\n  , CustomType    = require('./customtype')\n\n/**\n * Creates the XML for an XML-RPC method call.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to pass in the call.\n * @param {Function} callback - function (error, xml) { ... }\n *   - {Object|null} error    - Any errors that occurred while building the XML,\n *                              otherwise null.\n *   - {String} xml           - The method call XML.\n */\nexports.serializeMethodCall = function(method, params, encoding) {\n  var params = params || []\n\n  var options = { version: '1.0', allowSurrogateChars: true }\n\n  if (encoding) {\n    options.encoding = encoding\n  }\n\n  var xml = xmlBuilder.create('methodCall', options)\n    .ele('methodName')\n      .txt(method)\n    .up()\n    .ele('params')\n\n  params.forEach(function(param) {\n    serializeValue(param, xml.ele('param'))\n  })\n\n  // Includes the <?xml ...> declaration\n  return xml.doc().toString()\n}\n\n/**\n * Creates the XML for an XML-RPC method response.\n *\n * @param {mixed} value       - The value to pass in the response.\n * @param {Function} callback - function (error, xml) { ... }\n *   - {Object|null} error    - Any errors that occurred while building the XML,\n *                              otherwise null.\n *   - {String} xml           - The method response XML.\n */\nexports.serializeMethodResponse = function(result) {\n  var xml = xmlBuilder.create('methodResponse', { version: '1.0', allowSurrogateChars: true })\n    .ele('params')\n      .ele('param')\n\n  serializeValue(result, xml)\n\n  // Includes the <?xml ...> declaration\n  return xml.doc().toString()\n}\n\nexports.serializeFault = function(fault) {\n  var xml = xmlBuilder.create('methodResponse', { version: '1.0', allowSurrogateChars: true })\n    .ele('fault')\n\n  serializeValue(fault, xml)\n\n  // Includes the <?xml ...> declaration\n  return xml.doc().toString()\n}\n\nfunction serializeValue(value, xml) {\n  var stack     = [ { value: value, xml: xml } ]\n    , current   = null\n    , valueNode = null\n    , next      = null\n\n  while (stack.length > 0) {\n    current = stack[stack.length - 1]\n\n    if (current.index !== undefined) {\n      // Iterating a compound\n      next = getNextItemsFrame(current)\n      if (next) {\n        stack.push(next)\n      }\n      else {\n        stack.pop()\n      }\n    }\n    else {\n      // we're about to add a new value (compound or simple)\n      valueNode = current.xml.ele('value')\n      switch(typeof current.value) {\n        case 'boolean':\n          appendBoolean(current.value, valueNode)\n          stack.pop()\n          break\n        case 'string':\n          appendString(current.value, valueNode)\n          stack.pop()\n          break\n        case 'number':\n          appendNumber(current.value, valueNode)\n          stack.pop()\n          break\n        case 'object':\n          if (current.value === null) {\n            valueNode.ele('nil')\n            stack.pop()\n          }\n          else if (current.value instanceof Date) {\n            appendDatetime(current.value, valueNode)\n            stack.pop()\n          }\n          else if (Buffer.isBuffer(current.value)) {\n            appendBuffer(current.value, valueNode)\n            stack.pop()\n          }\n          else if (current.value instanceof CustomType) {\n            current.value.serialize(valueNode)\n            stack.pop()\n          }\n          else {\n            if (Array.isArray(current.value)) {\n              current.xml = valueNode.ele('array').ele('data')\n            }\n            else {\n              current.xml = valueNode.ele('struct')\n              current.keys = Object.keys(current.value)\n            }\n            current.index = 0\n            next = getNextItemsFrame(current)\n            if (next) {\n              stack.push(next)\n            }\n            else {\n              stack.pop()\n            }\n          }\n          break\n        default:\n          stack.pop()\n          break\n      }\n    }\n  }\n}\n\nfunction getNextItemsFrame(frame) {\n  var nextFrame = null\n\n  if (frame.keys) {\n    if (frame.index < frame.keys.length) {\n      var key    = frame.keys[frame.index++]\n        , member = frame.xml.ele('member').ele('name').text(key).up()\n      nextFrame = {\n        value: frame.value[key]\n      , xml: member\n      }\n    }\n  }\n  else if (frame.index < frame.value.length) {\n    nextFrame = {\n      value: frame.value[frame.index]\n    , xml: frame.xml\n    }\n    frame.index++\n  }\n\n  return nextFrame\n}\n\nfunction appendBoolean(value, xml) {\n  xml.ele('boolean').txt(value ? 1 : 0)\n}\n\nvar illegalChars = /^(?![^<&]*]]>[^<&]*)[^<&]*$/\nfunction appendString(value, xml) {\n  if (value.length === 0) {\n    xml.ele('string')\n  }\n  else if (!illegalChars.test(value)) {\n    xml.ele('string').d(value)\n  }\n  else {\n    xml.ele('string').txt(value)\n  }\n}\n\nfunction appendNumber(value, xml) {\n  if (value % 1 == 0) {\n    xml.ele('int').txt(value)\n  }\n  else {\n    xml.ele('double').txt(value)\n  }\n}\n\nfunction appendDatetime(value, xml) {\n  xml.ele('dateTime.iso8601').txt(dateFormatter.encodeIso8601(value))\n}\n\nfunction appendBuffer(value, xml) {\n  xml.ele('base64').txt(value.toString('base64'))\n}\n"]},"metadata":{},"sourceType":"script"}