{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    Serializer = require('./serializer'),\n    Deserializer = require('./deserializer'),\n    Cookies = require('./cookies');\n/**\n * Creates a Client object for making XML-RPC method calls.\n *\n * @constructor\n * @param {Object|String} options - Server options to make the HTTP request to.\n *                                  Either a URI string\n *                                  (e.g. 'http://localhost:9090') or an object\n *                                  with fields:\n *   - {String} host              - (optional)\n *   - {Number} port\n *   - {String} url               - (optional) - may be used instead of host/port pair\n *   - {Boolean} cookies          - (optional) - if true then cookies returned by server will be stored and sent back on the next calls.\n *                                  Also it will be possible to access/manipulate cookies via #setCookie/#getCookie methods\n * @param {Boolean} isSecure      - True if using https for making calls,\n *                                  otherwise false.\n * @return {Client}\n */\n\n\nfunction Client(options, isSecure) {\n  // Invokes with new if called without\n  if (false === this instanceof Client) {\n    return new Client(options, isSecure);\n  } // If a string URI is passed in, converts to URI fields\n\n\n  if (typeof options === 'string') {\n    options = url.parse(options);\n    options.host = options.hostname;\n    options.path = options.pathname;\n  }\n\n  if (typeof options.url !== 'undefined') {\n    var parsedUrl = url.parse(options.url);\n    options.host = parsedUrl.hostname;\n    options.path = parsedUrl.pathname;\n    options.port = parsedUrl.port;\n  } // Set the HTTP request headers\n\n\n  var headers = {\n    'User-Agent': 'NodeJS XML-RPC Client',\n    'Content-Type': 'text/xml',\n    'Accept': 'text/xml',\n    'Accept-Charset': 'UTF8',\n    'Connection': 'Keep-Alive'\n  };\n  options.headers = options.headers || {};\n\n  if (options.headers.Authorization == null && options.basic_auth != null && options.basic_auth.user != null && options.basic_auth.pass != null) {\n    var auth = options.basic_auth.user + ':' + options.basic_auth.pass;\n    options.headers['Authorization'] = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  for (var attribute in headers) {\n    if (options.headers[attribute] === undefined) {\n      options.headers[attribute] = headers[attribute];\n    }\n  }\n\n  options.method = 'POST';\n  this.options = options;\n  this.isSecure = isSecure;\n  this.headersProcessors = {\n    processors: [],\n    composeRequest: function (headers) {\n      this.processors.forEach(function (p) {\n        p.composeRequest(headers);\n      });\n    },\n    parseResponse: function (headers) {\n      this.processors.forEach(function (p) {\n        p.parseResponse(headers);\n      });\n    }\n  };\n\n  if (options.cookies) {\n    this.cookies = new Cookies();\n    this.headersProcessors.processors.unshift(this.cookies);\n  }\n}\n/**\n * Makes an XML-RPC call to the server specified by the constructor's options.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to send in the call.\n * @param {Function} callback - function(error, value) { ... }\n *   - {Object|null} error    - Any errors when making the call, otherwise null.\n *   - {mixed} value          - The value returned in the method response.\n */\n\n\nClient.prototype.methodCall = function methodCall(method, params, callback) {\n  var options = this.options;\n  var xml = Serializer.serializeMethodCall(method, params, options.encoding);\n  var transport = this.isSecure ? https : http;\n  options.headers['Content-Length'] = Buffer.byteLength(xml, 'utf8');\n  this.headersProcessors.composeRequest(options.headers);\n  var request = transport.request(options, function (response) {\n    var body = [];\n    response.on('data', function (chunk) {\n      body.push(chunk);\n    });\n\n    function __enrichError(err) {\n      Object.defineProperty(err, 'req', {\n        value: request\n      });\n      Object.defineProperty(err, 'res', {\n        value: response\n      });\n      Object.defineProperty(err, 'body', {\n        value: body.join('')\n      });\n      return err;\n    }\n\n    if (response.statusCode == 404) {\n      callback(__enrichError(new Error('Not Found')));\n    } else {\n      this.headersProcessors.parseResponse(response.headers);\n      var deserializer = new Deserializer(options.responseEncoding);\n      deserializer.deserializeMethodResponse(response, function (err, result) {\n        if (err) {\n          err = __enrichError(err);\n        }\n\n        callback(err, result);\n      });\n    }\n  }.bind(this));\n  request.on('error', callback);\n  request.write(xml, 'utf8');\n  request.end();\n};\n/**\n * Gets the cookie value by its name. The latest value received from servr with 'Set-Cookie' header is returned\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be obtained or changed\n * @return {*} cookie's value\n */\n\n\nClient.prototype.getCookie = function getCookie(name) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n\n  return this.cookies.get(name);\n};\n/**\n * Sets the cookie value by its name. The cookie will be sent to the server during the next xml-rpc call.\n * The method returns client itself, so it is possible to chain calls like the following:\n *\n * <code>\n *   client.cookie('login', 'alex').cookie('password', '123');\n * </code>\n *\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be changed\n * @param {String} value value to be set.\n * @return {*} client object itself\n */\n\n\nClient.prototype.setCookie = function setCookie(name, value) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n\n  this.cookies.set(name, value);\n  return this;\n};\n\nmodule.exports = Client;","map":{"version":3,"sources":["/home/pinchas/code/projects/movie-finder/node_modules/xmlrpc/lib/client.js"],"names":["http","require","https","url","Serializer","Deserializer","Cookies","Client","options","isSecure","parse","host","hostname","path","pathname","parsedUrl","port","headers","Authorization","basic_auth","user","pass","auth","Buffer","toString","attribute","undefined","method","headersProcessors","processors","composeRequest","forEach","p","parseResponse","cookies","unshift","prototype","methodCall","params","callback","xml","serializeMethodCall","encoding","transport","byteLength","request","response","body","on","chunk","push","__enrichError","err","Object","defineProperty","value","join","statusCode","Error","deserializer","responseEncoding","deserializeMethodResponse","result","bind","write","end","getCookie","name","get","setCookie","set","module","exports"],"mappings":"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","sourcesContent":["var http         = require('http')\n  , https        = require('https')\n  , url          = require('url')\n  , Serializer   = require('./serializer')\n  , Deserializer = require('./deserializer')\n  , Cookies      = require('./cookies')\n\n/**\n * Creates a Client object for making XML-RPC method calls.\n *\n * @constructor\n * @param {Object|String} options - Server options to make the HTTP request to.\n *                                  Either a URI string\n *                                  (e.g. 'http://localhost:9090') or an object\n *                                  with fields:\n *   - {String} host              - (optional)\n *   - {Number} port\n *   - {String} url               - (optional) - may be used instead of host/port pair\n *   - {Boolean} cookies          - (optional) - if true then cookies returned by server will be stored and sent back on the next calls.\n *                                  Also it will be possible to access/manipulate cookies via #setCookie/#getCookie methods\n * @param {Boolean} isSecure      - True if using https for making calls,\n *                                  otherwise false.\n * @return {Client}\n */\nfunction Client(options, isSecure) {\n\n  // Invokes with new if called without\n  if (false === (this instanceof Client)) {\n    return new Client(options, isSecure)\n  }\n\n  // If a string URI is passed in, converts to URI fields\n  if (typeof options === 'string') {\n    options = url.parse(options)\n    options.host = options.hostname\n    options.path = options.pathname\n  }\n\n  if (typeof options.url !== 'undefined') {\n    var parsedUrl = url.parse(options.url);\n    options.host = parsedUrl.hostname;\n    options.path = parsedUrl.pathname;\n    options.port = parsedUrl.port;\n  }\n\n  // Set the HTTP request headers\n  var headers = {\n    'User-Agent'     : 'NodeJS XML-RPC Client'\n  , 'Content-Type'   : 'text/xml'\n  , 'Accept'         : 'text/xml'\n  , 'Accept-Charset' : 'UTF8'\n  , 'Connection'     : 'Keep-Alive'\n  }\n  options.headers = options.headers || {}\n\n  if (options.headers.Authorization == null &&\n      options.basic_auth != null &&\n      options.basic_auth.user != null &&\n      options.basic_auth.pass != null)\n  {\n    var auth = options.basic_auth.user + ':' + options.basic_auth.pass\n    options.headers['Authorization'] = 'Basic ' + new Buffer(auth).toString('base64')\n  }\n\n  for (var attribute in headers) {\n    if (options.headers[attribute] === undefined) {\n      options.headers[attribute] = headers[attribute]\n    }\n  }\n\n  options.method = 'POST'\n  this.options = options\n\n  this.isSecure = isSecure\n  this.headersProcessors = {\n    processors: [],\n    composeRequest: function(headers) {\n      this.processors.forEach(function(p) {p.composeRequest(headers);})\n    },\n    parseResponse: function(headers) {\n      this.processors.forEach(function(p) {p.parseResponse(headers);})\n    }\n  };\n  if (options.cookies) {\n    this.cookies = new Cookies();\n    this.headersProcessors.processors.unshift(this.cookies);\n  }\n}\n\n/**\n * Makes an XML-RPC call to the server specified by the constructor's options.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to send in the call.\n * @param {Function} callback - function(error, value) { ... }\n *   - {Object|null} error    - Any errors when making the call, otherwise null.\n *   - {mixed} value          - The value returned in the method response.\n */\nClient.prototype.methodCall = function methodCall(method, params, callback) {\n  var options   = this.options\n  var xml       = Serializer.serializeMethodCall(method, params, options.encoding)\n  var transport = this.isSecure ? https : http\n\n  options.headers['Content-Length'] = Buffer.byteLength(xml, 'utf8')\n  this.headersProcessors.composeRequest(options.headers)\n  var request = transport.request(options, function(response) {\n\n    var body = []\n    response.on('data', function (chunk) { body.push(chunk) })\n\n    function __enrichError (err) {\n      Object.defineProperty(err, 'req', { value: request })\n      Object.defineProperty(err, 'res', { value: response })\n      Object.defineProperty(err, 'body', { value: body.join('') })\n      return err\n    }\n\n    if (response.statusCode == 404) {\n      callback(__enrichError(new Error('Not Found')))\n    }\n    else {\n      this.headersProcessors.parseResponse(response.headers)\n\n      var deserializer = new Deserializer(options.responseEncoding)\n\n      deserializer.deserializeMethodResponse(response, function(err, result) {\n        if (err) {\n          err = __enrichError(err)\n        }\n        callback(err, result)\n      })\n    }\n  }.bind(this))\n\n  request.on('error', callback)\n  request.write(xml, 'utf8')\n  request.end()\n}\n\n/**\n * Gets the cookie value by its name. The latest value received from servr with 'Set-Cookie' header is returned\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be obtained or changed\n * @return {*} cookie's value\n */\nClient.prototype.getCookie = function getCookie(name) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n  return this.cookies.get(name);\n}\n\n/**\n * Sets the cookie value by its name. The cookie will be sent to the server during the next xml-rpc call.\n * The method returns client itself, so it is possible to chain calls like the following:\n *\n * <code>\n *   client.cookie('login', 'alex').cookie('password', '123');\n * </code>\n *\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be changed\n * @param {String} value value to be set.\n * @return {*} client object itself\n */\nClient.prototype.setCookie = function setCookie(name, value) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n  this.cookies.set(name, value);\n  return this;\n}\n\nmodule.exports = Client\n\n"]},"metadata":{},"sourceType":"script"}