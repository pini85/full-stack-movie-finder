{"ast":null,"code":"const OS = require('./lib/opensubtitles.js');\n\nconst libhash = require('./lib/hash.js');\n\nconst libsearch = require('./lib/search.js');\n\nconst libupload = require('./lib/upload.js');\n\nconst libid = require('./lib/identify.js');\n\nmodule.exports = class OpenSubtitles {\n  /**\r\n   * Construct the module's skeleton\r\n   * @param {Object}|{String} creds - the required information to use OpenSubtitles, can be simply the UA\r\n   *\r\n   * @param {String}          creds.useragent - mandatory, the OpenSubtitles User Agent\r\n   * @param {String}          creds.endpoint - optionnal, the endpoint to use.\r\n   * @param {Boolean}         creds.ssl - optionnal, set to true to use https.\r\n   * @param {String}          creds.username - optionnal, the username of a specific user\r\n   * @param {String}          creds.password - optionnal, the password of a specific user (can be MD5)\r\n   */\n  constructor(creds) {\n    if (!creds || typeof creds === 'object' && !creds.useragent) throw Error('Missing useragent');\n    this.credentials = {\n      username: creds.username || String(),\n      password: creds.password || String(),\n      useragent: creds.useragent || creds,\n      status: Object(),\n      userinfo: Object()\n    };\n    this.api = new OS(creds.endpoint, creds.ssl);\n  }\n  /**\r\n   * Log-in as user or anonymously, returns a token\r\n   */\n\n\n  login() {\n    if (this.credentials.status.auth_as === this.credentials.username && this.credentials.status.ttl > Date.now()) {\n      return Promise.resolve({\n        token: this.credentials.status.token,\n        userinfo: this.credentials.userinfo\n      });\n    }\n\n    return this.api.LogIn(this.credentials.username, this.credentials.password, 'en', this.credentials.useragent).then(response => {\n      if (response.token && response.status && response.status.match(/200/)) {\n        this.credentials.status.ttl = Date.now() + 895000; // ~15 min\n\n        this.credentials.status.token = response.token;\n        this.credentials.status.auth_as = this.credentials.username;\n        this.credentials.userinfo = response.data;\n        return {\n          token: response.token,\n          userinfo: response.data\n        };\n      }\n\n      this.credentials.status = this.credentials.userinfo = Object();\n      throw Error(response.status || 'LogIn unknown error');\n    });\n  }\n  /**\r\n   * Search for subtitles\r\n   * @param {Object}          info - information about the video to be subtitled\r\n   *\r\n   * @param {String}|{Array}  info.extensions - Accepted extensions, defaults to 'srt' (values: srt, sub, smi, txt, ssa, ass, mpl)\r\n   * @param {String}|{Array}  info.sublanguageid - Desired subtitle lang, ISO639-3 langcode, defaults to 'all'\r\n   * @param {String}          info.hash - Size + 64bit checksum of the first and last 64k\r\n   * @param {String}          info.path - Absolute path to the video file, it allows to automatically calculate 'hash'\r\n   * @param {String}|{Int}    info.filesize - Total size, in bytes\r\n   * @param {String}          info.filename - The video file name. Better if extension is included\r\n   * @param {String}|{Int}    info.season - If TV Episode\r\n   * @param {String}|{Int}    info.episode - If TV Episode\r\n   * @param {String}|{Int}    info.imdbid - IMDB id with or without leading 'tt'\r\n   * @param {String}|{Int}    info.fps - Number of frames per sec in the video\r\n   * @param {String}          info.query - Text-based query, this is not recommended\r\n   * @param {String}|{Int}    info.limit - Number of subtitles to return for each language, can be 'best', 'all' or an arbitrary number. Defaults to 'best'\r\n   */\n\n\n  search(info) {\n    let subs = Array();\n    return this.login().then(() => libsearch.optimizeQueryTerms(info)).then(optimizedQT => {\n      return Promise.all(optimizedQT.map(op => {\n        return this.api.SearchSubtitles(this.credentials.status.token, [op]).then(result => subs = subs.concat(result.data));\n      }));\n    }).then(() => libsearch.optimizeSubs(subs, info)).then(list => libsearch.filter(list, info));\n  }\n  /**\r\n   * Upload a subtitle\r\n   * @param {Object}          subtitle - information about the video to be subtitled\r\n   *\r\n   * @param {String}          subtitle.path - Mandatory, absolute path to the video file\r\n   * @param {String}          subtitle.subpath - Mandatory, absolute path to the subtitle file\r\n   * @param {String}|{Int}    subtitle.imdbid - Recommended, IMDB id with or without leading 'tt'\r\n   * @param {String}          subtitle.sublanguageid - Optionnal, subtitle lang, ISO639-3 langcode (autodetected upstream)\r\n   * @param {String}          subtitle.moviereleasename - Optionnal, the release tag/name\r\n   * @param {String}          subtitle.movieaka - Optionnal, alternative title\r\n   * @param {String}|{Int}    subtitle.moviefps - Optionnal, number of frames per sec\r\n   * @param {String}|{Int}    subtitle.movieframes - Optionnal, total number of frames\r\n   * @param {String}|{Int}    subtitle.movietimems - Optionnal, total time in milliseconds\r\n   * @param {String}|{Boolean}subtitle.highdefinition - Optionnal, is the video more than 720p? '1' or '0', true or false\r\n   * @param {String}|{Boolean}subtitle.hearingimpaired - Optionnal, does the subtitle have descriptions for every sound? '1' or '0', true or false\r\n   * @param {String}|{Boolean}subtitle.automatictranslation - Optionnal, is the subtitle machine-translated? '1' or '0', true or false\r\n   * @param {String}          subtitle.subauthorcomment - Optionnal, commentary for the uploaded subtitle\r\n   * @param {String}          subtitle.subtranslator - Optionnal, person who translated the subtitles\r\n   */\n\n\n  upload(subtitle) {\n    return new Promise((resolve, reject) => {\n      let persistent_data = Object();\n      this.login().then(() => libupload.createTryData(subtitle)).then(tryArray => {\n        persistent_data = tryArray.cd1;\n        return this.api.TryUploadSubtitles(this.credentials.status.token, tryArray);\n      }).then(response => {\n        if (response.alreadyindb === 1) {\n          resolve(response); // it exists, don't go further\n        } else {\n          persistent_data.subpath = subtitle.subpath; // inject subpath\n\n          return libupload.parseResponse(response, persistent_data);\n        }\n      }).then(libupload.createContent).then(libupload.arrangeUploadData).then(uploadArray => this.api.UploadSubtitles(this.credentials.status.token, uploadArray)).then(response => {\n        if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'UploadSubtitles unknown error');\n        resolve(response);\n      }).catch(reject);\n    });\n  }\n  /**\r\n   * Extract Movie Hash & Movie Bytes Size from a video\r\n   *\r\n   * @param {String} path - Absolute path to a video file\r\n   * @returns {Object} - An object containing moviebytesize and moviehash\r\n   */\n\n\n  hash(path) {\n    if (!path) throw Error('Missing path');\n    return libhash.computeHash(path);\n  }\n  /**\r\n   * Movie identification service, get imdb information, send moviehashes\r\n   *\r\n   * @param {Object}  query\r\n   * @param {String}  query.path - Absolute path to a video file\r\n   * @param {Boolean} [query.extend] - Fetches metadata from OpenSubtitles\r\n   * @param {String}  [query.imdb] - Matching IMDb id\r\n   * @param {Number}  [query.moviebytesize] - Filesize in bytes\r\n   * @param {String}  [query.moviehash] - OSDb hash\r\n   */\n\n\n  identify(query) {\n    if (!query) throw Error('Missing path');\n    if (!query.path && !query.moviehash && !query.moviebytesize) query = {\n      path: query\n    };\n    const isFileLocal = !(query.moviehash && query.moviebytesize);\n    return this.login().then(() => {\n      if (query.moviehash && query.moviebytesize) {\n        return {\n          moviebytesize: query.moviebytesize,\n          moviehash: query.moviehash\n        };\n      }\n\n      return this.hash(query.path);\n    }).then(info => {\n      query.moviehash = info.moviehash;\n      query.moviebytesize = info.moviebytesize;\n      return this.api.CheckMovieHash(this.credentials.status.token, [query.moviehash]);\n    }).then(response => {\n      if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'OpenSubtitles unknown error');\n      let id;\n\n      if (isFileLocal) {\n        id = query.imdb || libid.readNFO(query.path);\n      }\n\n      if (response.data[query.moviehash].length === 0 && isFileLocal && id) {\n        return this.api.InsertMovieHash(this.credentials.status.token, [{\n          moviehash: query.moviehash,\n          moviebytesize: query.moviebytesize,\n          imdbid: id.replace('tt', ''),\n          moviefilename: require('path').basename(query.path)\n        }]);\n      } else {\n        return response;\n      }\n    }).then(response => libid.parseResponse(response, query)).then(data => {\n      if (data.metadata && data.metadata.imdbid && query.extend) {\n        return this.api.GetIMDBMovieDetails(this.credentials.status.token, data.metadata.imdbid.replace('tt', '')).then(ext => libid.extend(data, ext));\n      } else {\n        return data;\n      }\n    });\n  }\n  /**\r\n   * Extract md5 hash from a subtitle file\r\n   * @param {String}          path - Mandatory, absolute path to a subtitle file\r\n   */\n\n\n  md5(path) {\n    if (!path) throw Error('Missing path');\n    return libhash.computeMD5(path);\n  }\n\n};","map":{"version":3,"sources":["/home/pinchas/code/projects/movie-finder/node_modules/opensubtitles-api/index.js"],"names":["OS","require","libhash","libsearch","libupload","libid","module","exports","OpenSubtitles","constructor","creds","useragent","Error","credentials","username","String","password","status","Object","userinfo","api","endpoint","ssl","login","auth_as","ttl","Date","now","Promise","resolve","token","LogIn","then","response","match","data","search","info","subs","Array","optimizeQueryTerms","optimizedQT","all","map","op","SearchSubtitles","result","concat","optimizeSubs","list","filter","upload","subtitle","reject","persistent_data","createTryData","tryArray","cd1","TryUploadSubtitles","alreadyindb","subpath","parseResponse","createContent","arrangeUploadData","uploadArray","UploadSubtitles","catch","hash","path","computeHash","identify","query","moviehash","moviebytesize","isFileLocal","CheckMovieHash","id","imdb","readNFO","length","InsertMovieHash","imdbid","replace","moviefilename","basename","metadata","extend","GetIMDBMovieDetails","ext","md5","computeMD5"],"mappings":"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","sourcesContent":["const OS = require('./lib/opensubtitles.js')\r\nconst libhash = require('./lib/hash.js')\r\nconst libsearch = require('./lib/search.js')\r\nconst libupload = require('./lib/upload.js')\r\nconst libid = require('./lib/identify.js')\r\n\r\nmodule.exports = class OpenSubtitles {\r\n\r\n    /**\r\n     * Construct the module's skeleton\r\n     * @param {Object}|{String} creds - the required information to use OpenSubtitles, can be simply the UA\r\n     *\r\n     * @param {String}          creds.useragent - mandatory, the OpenSubtitles User Agent\r\n     * @param {String}          creds.endpoint - optionnal, the endpoint to use.\r\n     * @param {Boolean}         creds.ssl - optionnal, set to true to use https.\r\n     * @param {String}          creds.username - optionnal, the username of a specific user\r\n     * @param {String}          creds.password - optionnal, the password of a specific user (can be MD5)\r\n     */\r\n    constructor(creds) {\r\n        if (!creds || (typeof creds === 'object' && !creds.useragent)) throw Error('Missing useragent')\r\n\r\n        this.credentials = {\r\n            username: creds.username || String(),\r\n            password: creds.password || String(),\r\n            useragent: creds.useragent || creds,\r\n            status: Object(),\r\n            userinfo: Object()\r\n        }\r\n\r\n        this.api = new OS(creds.endpoint, creds.ssl)\r\n    }\r\n\r\n\r\n    /**\r\n     * Log-in as user or anonymously, returns a token\r\n     */\r\n    login() {\r\n        if (this.credentials.status.auth_as === this.credentials.username && this.credentials.status.ttl > Date.now()) {\r\n            return Promise.resolve({\r\n                token: this.credentials.status.token,\r\n                userinfo: this.credentials.userinfo\r\n            })\r\n        }\r\n\r\n        return this.api.LogIn(this.credentials.username, this.credentials.password, 'en', this.credentials.useragent).then(response => {\r\n            if (response.token && (response.status && response.status.match(/200/))) {\r\n                this.credentials.status.ttl = Date.now() + 895000 // ~15 min\r\n                this.credentials.status.token = response.token\r\n                this.credentials.status.auth_as = this.credentials.username\r\n                this.credentials.userinfo = response.data\r\n                return {\r\n                    token: response.token,\r\n                    userinfo: response.data\r\n                }\r\n            }\r\n\r\n            this.credentials.status = this.credentials.userinfo = Object()\r\n            throw Error(response.status || 'LogIn unknown error')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Search for subtitles\r\n     * @param {Object}          info - information about the video to be subtitled\r\n     *\r\n     * @param {String}|{Array}  info.extensions - Accepted extensions, defaults to 'srt' (values: srt, sub, smi, txt, ssa, ass, mpl)\r\n     * @param {String}|{Array}  info.sublanguageid - Desired subtitle lang, ISO639-3 langcode, defaults to 'all'\r\n     * @param {String}          info.hash - Size + 64bit checksum of the first and last 64k\r\n     * @param {String}          info.path - Absolute path to the video file, it allows to automatically calculate 'hash'\r\n     * @param {String}|{Int}    info.filesize - Total size, in bytes\r\n     * @param {String}          info.filename - The video file name. Better if extension is included\r\n     * @param {String}|{Int}    info.season - If TV Episode\r\n     * @param {String}|{Int}    info.episode - If TV Episode\r\n     * @param {String}|{Int}    info.imdbid - IMDB id with or without leading 'tt'\r\n     * @param {String}|{Int}    info.fps - Number of frames per sec in the video\r\n     * @param {String}          info.query - Text-based query, this is not recommended\r\n     * @param {String}|{Int}    info.limit - Number of subtitles to return for each language, can be 'best', 'all' or an arbitrary number. Defaults to 'best'\r\n     */\r\n    search(info) {\r\n        let subs = Array()\r\n\r\n        return this.login()\r\n            .then(() => libsearch.optimizeQueryTerms(info))\r\n            .then(optimizedQT => {\r\n                return Promise.all(optimizedQT.map(op => {\r\n                    return this.api.SearchSubtitles(this.credentials.status.token, [op]).then(result => subs = subs.concat(result.data))\r\n                }))\r\n            })\r\n            .then(() => libsearch.optimizeSubs(subs, info))\r\n            .then(list => libsearch.filter(list, info))\r\n    }\r\n\r\n    /**\r\n     * Upload a subtitle\r\n     * @param {Object}          subtitle - information about the video to be subtitled\r\n     *\r\n     * @param {String}          subtitle.path - Mandatory, absolute path to the video file\r\n     * @param {String}          subtitle.subpath - Mandatory, absolute path to the subtitle file\r\n     * @param {String}|{Int}    subtitle.imdbid - Recommended, IMDB id with or without leading 'tt'\r\n     * @param {String}          subtitle.sublanguageid - Optionnal, subtitle lang, ISO639-3 langcode (autodetected upstream)\r\n     * @param {String}          subtitle.moviereleasename - Optionnal, the release tag/name\r\n     * @param {String}          subtitle.movieaka - Optionnal, alternative title\r\n     * @param {String}|{Int}    subtitle.moviefps - Optionnal, number of frames per sec\r\n     * @param {String}|{Int}    subtitle.movieframes - Optionnal, total number of frames\r\n     * @param {String}|{Int}    subtitle.movietimems - Optionnal, total time in milliseconds\r\n     * @param {String}|{Boolean}subtitle.highdefinition - Optionnal, is the video more than 720p? '1' or '0', true or false\r\n     * @param {String}|{Boolean}subtitle.hearingimpaired - Optionnal, does the subtitle have descriptions for every sound? '1' or '0', true or false\r\n     * @param {String}|{Boolean}subtitle.automatictranslation - Optionnal, is the subtitle machine-translated? '1' or '0', true or false\r\n     * @param {String}          subtitle.subauthorcomment - Optionnal, commentary for the uploaded subtitle\r\n     * @param {String}          subtitle.subtranslator - Optionnal, person who translated the subtitles\r\n     */\r\n    upload(subtitle) {\r\n        return new Promise((resolve, reject) => {\r\n            let persistent_data = Object()\r\n\r\n            this.login()\r\n                .then(() => libupload.createTryData(subtitle))\r\n                .then(tryArray => {\r\n                    persistent_data = tryArray.cd1\r\n                    return this.api.TryUploadSubtitles(this.credentials.status.token, tryArray)\r\n                })\r\n                .then(response => {\r\n                    if (response.alreadyindb === 1) {\r\n                        resolve(response) // it exists, don't go further\r\n                    } else {\r\n                        persistent_data.subpath = subtitle.subpath // inject subpath\r\n                        return libupload.parseResponse(response, persistent_data)\r\n                    }\r\n                })\r\n                .then(libupload.createContent)\r\n                .then(libupload.arrangeUploadData)\r\n                .then(uploadArray => this.api.UploadSubtitles(this.credentials.status.token, uploadArray))\r\n                .then(response => {\r\n                    if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'UploadSubtitles unknown error')\r\n                    resolve(response)\r\n                }).catch(reject)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Extract Movie Hash & Movie Bytes Size from a video\r\n     *\r\n     * @param {String} path - Absolute path to a video file\r\n     * @returns {Object} - An object containing moviebytesize and moviehash\r\n     */\r\n    hash(path) {\r\n        if (!path) throw Error('Missing path')\r\n        return libhash.computeHash(path)\r\n    }\r\n\r\n    /**\r\n     * Movie identification service, get imdb information, send moviehashes\r\n     *\r\n     * @param {Object}  query\r\n     * @param {String}  query.path - Absolute path to a video file\r\n     * @param {Boolean} [query.extend] - Fetches metadata from OpenSubtitles\r\n     * @param {String}  [query.imdb] - Matching IMDb id\r\n     * @param {Number}  [query.moviebytesize] - Filesize in bytes\r\n     * @param {String}  [query.moviehash] - OSDb hash\r\n     */\r\n    identify(query) {\r\n        if (!query) throw Error('Missing path')\r\n        if (!query.path && !query.moviehash && !query.moviebytesize) query = {path: query}\r\n\r\n        const isFileLocal = !(query.moviehash && query.moviebytesize);\r\n\r\n        return this.login()\r\n            .then(() => {\r\n                if (query.moviehash && query.moviebytesize) {\r\n                    return {\r\n                        moviebytesize: query.moviebytesize,\r\n                        moviehash: query.moviehash\r\n                    }\r\n                }\r\n                return this.hash(query.path)\r\n            })\r\n            .then(info => {\r\n                query.moviehash = info.moviehash\r\n                query.moviebytesize = info.moviebytesize\r\n                return this.api.CheckMovieHash(this.credentials.status.token, [query.moviehash])\r\n            })\r\n            .then(response => {\r\n                if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'OpenSubtitles unknown error')\r\n\r\n                let id\r\n                if (isFileLocal) {\r\n                    id = query.imdb || libid.readNFO(query.path)\r\n                }\r\n\r\n                if (response.data[query.moviehash].length === 0 && isFileLocal && id) {\r\n                    return this.api.InsertMovieHash(this.credentials.status.token, [{\r\n                        moviehash: query.moviehash,\r\n                        moviebytesize: query.moviebytesize,\r\n                        imdbid: id.replace('tt', ''),\r\n                        moviefilename: require('path').basename(query.path)\r\n                    }])\r\n                } else {\r\n                    return response\r\n                }\r\n            })\r\n            .then(response => libid.parseResponse(response, query))\r\n            .then(data => {\r\n                if (data.metadata && data.metadata.imdbid && query.extend) {\r\n                    return this.api.GetIMDBMovieDetails(this.credentials.status.token, data.metadata.imdbid.replace('tt', ''))\r\n                        .then(ext => libid.extend(data, ext))\r\n                } else {\r\n                    return data\r\n                }\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Extract md5 hash from a subtitle file\r\n     * @param {String}          path - Mandatory, absolute path to a subtitle file\r\n     */\r\n    md5(path) {\r\n        if (!path) throw Error('Missing path')\r\n        return libhash.computeMD5(path)\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}